#!/usr/local/bin/perl
######################################################################################
# Revision: Xiang Guo, Jan, 2008.
# Add number of gaps in left and right end (30 aa) of protein sequence to htab file
######################################################################################

use strict;
use DBI;
use Cwd;

#    require "$ENV{HMM_SCRIPTS}/hmm_lib.pl";
my $usage = <<_EOT_;
NAME
    htab.pl - parse output files generated by hmmsearch and hmmpfam, and 
              output btab-like table of results.

SYNOPSIS
    cat <search_output_file> | htab.pl [OPTION]   >> research_results
    'ls' file_name | htab.pl -f [OPTION]

DESCRIPTION
    htab.pl parses HMM search results for HMMER.  It will parse the output 
    of a single search from STDIN and output tab-delimited data for each 
    hit to STDOUT. Multiple files may be processed using the -f option (see 
    below). During parsing, the size and cutoffs for each HMM is gathered 
    from the egad database. HMMER version 2.1.1 output is currently supported.

    -f    a flag indicating that the input is a list of file names to be parsed.
          Each file is processed and the results are saved as "filename.htab"
          in the directory where the file is. 
    -h    a flag to print this help message
    -m    a flag for supporting output from multiple query sequences
    -s    a flag to skip database query
    -t    input a value for trusted_cutoff (for hmmsearch log, replace the value retrieved from db)
    -n    input a value for noise_cutoff   (for hmmsearch log, replace the value retrieved from db)
    -q    quiet mode, no output of htab, can still generate alignment if specified.
    -Z    flag for debug mode, output debug information

    Description of the output format (tab-delimited, one line per domain hit)
    col  perl-col   description
    1      [0]      HMM accession                        
    2      [1]      Date of the htab job          
    3      [2]      Length of the HMM (from database)
    4      [3]      Search method (typically hmmsearch or hmmpfam)
    5      [4]      Name of the database file
    6      [5]      Protein accession
    7      [6]      Start position of HMM match - hmm-f
    8      [7]      End position of HMM match - hmm-t        
    9      [8]      Start position of the protein - seq-f
    10     [9]      End position of the protein  - seq-t
    11	   [10]     Number of gaps in left end of the protein (30 aa) - gap-f
    12	   [11]     Number of gaps in right end of the protein (30 aa) - gap-t
    13     [12]     (unassigned)
    14     [13]     Domain score
    15     [14]     Total score
    16     [15]     Domain number
    17     [16]     Total number of domains
    18     [17]     Biological description of the HMM (maybe truncated by hmmsearch or hmmpfam, but
                               can be recovered from DB using hmm_com_name if -s is not used)
    19     [18]     Biological description of the protein (maybe truncated by hmmsearch or hmmpfam)
    20     [19]     Trusted cutoff of the HMM (from database)
    21     [20]     Noise cutoff of the HMM (from database)
    22     [21]     Expect value for the whole match
    23     [22]     Expect value for the domain match

EXAMPLE
   ls  xxx/xxxx/xxxx/file_name* | htab.pl -f
   cat xxx/xxxx/xxxx/file_name* | htab.pl

_EOT_

my ( %info, @file );
$info{'db_type'} = "Sybase";
$info{'server'}  = "SYBTIGR";
$info{'db'}      = "egad";
$info{user}      = "access";
$info{password}  = "access";
&get_options( \%info, $usage );
$info{db_proc} =
  &connect_db( $info{db}, $info{db_type}, $info{server}, $info{user},
	$info{password} )
  unless ( $info{no_db} );

if ( $info{file} ) {
	my @file = <>;
	$info{align_file} = "";
	for (@file) {
		my $file = $1 if ( $_ =~ /^(\S+)/ );
		print $file, "\n";

		if ( !( -s $file ) ) {
			print "***Error: can not find file $file or it has zero size\n";
			next;
		}
		&parse_hmm_hits(
			$file,                 $info{db},
			$info{db_proc},        $usage,
			$info{debug},          $info{align_output},
			$info{align_file},     $info{b1_cutoff},
			$info{b2_cutoff},      $info{e1_cutoff},
			$info{e2_cutoff},      $info{format},
			$info{quiet},          $info{noise_cutoff},
			$info{trusted_cutoff}, '',
			'',                    '',
			'',                    '',
			'',                    '',
			$info{multi}
		);
	}
}
else {
	&parse_hmm_hits(
		'',                    $info{db},
		$info{db_proc},        $usage,
		$info{debug},          $info{align_output},
		$info{align_file},     $info{b1_cutoff},
		$info{b2_cutoff},      $info{e1_cutoff},
		$info{e2_cutoff},      $info{format},
		$info{quiet},          $info{noise_cutoff},
		$info{trusted_cutoff}, '',
		'',                    '',
		'',                    '',
		'',                    $info{multi}
	);
}

$info{db_proc}->disconnect if ( defined $info{db_proc} );
exit(0);


##########################################################################
## Helper function
##########################################################################
sub get_options {
	use strict;
	use Getopt::Std;
	use vars
	  qw($opt_A $opt_B $opt_C $opt_D $opt_E $opt_F $opt_Z $opt_f $opt_h $opt_m $opt_n $opt_q $opt_s $opt_t);
	my ( $info_r, $usage ) = @_;
	getopts('A:B:C:D:E:F:Zfhmn:qst:')
	  or die "Wrong input options. \n";    #get options
	die "$usage" if ($opt_h);
	$$info_r{debug} = 1 if ($opt_Z);
	$$info_r{file}  = 1 if ($opt_f);
	$$info_r{quiet} = 1 if ($opt_q);
	$$info_r{multi} = 1 if ($opt_m);
	$$info_r{no_db} = 1 if ($opt_s);
	$$info_r{noise_cutoff}   = ( $opt_n ne '' ? $opt_n : '' );
	$$info_r{trusted_cutoff} = ( $opt_t ne '' ? $opt_t : '' );
	$$info_r{align_file}     = ( $opt_A ne '' ? $opt_A : "protein_alignment" );
	$$info_r{b1_cutoff}      = ( $opt_B ne '' ? $opt_B : -2000 );
	$$info_r{b2_cutoff}      = ( $opt_C ne '' ? $opt_C : -2000 );
	$$info_r{e1_cutoff}      = ( $opt_D ne '' ? $opt_D : 100 );
	$$info_r{e2_cutoff}      = ( $opt_E ne '' ? $opt_E : 100 );
	$$info_r{format}         = ( $opt_F ne '' ? $opt_F : "msf" );
	$$info_r{align_output}   = 1
	  if ( $opt_A ne ''
		or $opt_B ne ''
		or $opt_C ne ''
		or $opt_D ne ''
		or $opt_E ne ''
		or $opt_F ne '' );
}

##########################################################################
## Modified function from hmm_lib.pl
##########################################################################
sub parse_hmm_hits {
	use strict;

	my (
		$file,       $db,           $db_proc,        $usage,
		$debug,      $align_output, $align_file,     $b1_cutoff,
		$b2_cutoff,  $e1_cutoff,    $e2_cutoff,      $format,
		$quiet,      $noise_cutoff, $trusted_cutoff, $output_dir,
		$tb1_cutoff, $tb2_cutoff,   $te1_cutoff,     $te2_cutoff,
		$inverse,    $multi
	  )
	  = @_;

	#   following are entry-wide variables
	if ( $inverse ne '' ) {
		$tb1_cutoff = ( $tb1_cutoff ne '' ? $tb1_cutoff : 2000 );
		$tb2_cutoff = ( $tb2_cutoff ne '' ? $tb2_cutoff : 2000 );
		$te1_cutoff = ( $te1_cutoff ne '' ? $te1_cutoff : -100 );
		$te2_cutoff = ( $te2_cutoff ne '' ? $te2_cutoff : -100 );
	}
	else {
		$inverse    = 0;
		$tb1_cutoff = ( $tb1_cutoff ne '' ? $tb1_cutoff : -2000 );
		$tb2_cutoff = ( $tb2_cutoff ne '' ? $tb2_cutoff : -2000 );
		$te1_cutoff = ( $te1_cutoff ne '' ? $te1_cutoff : 100 );
		$te2_cutoff = ( $te2_cutoff ne '' ? $te2_cutoff : 100 );
	}

	my ( @line, $method, $query_obj, $query_db, %seq, $output, $prot_desc,
		$fhtab );
	my $version;

	# drink in the output from file or stdin
	if ( $file ne '' ) {
		chomp $file;
		open( FH, "$file" ) || die "Can't open $file for reading: $!\n";
		@line = <FH>;
		close FH;
		$fhtab = "$file.htab";
		$fhtab =~ s:^(.*/)?:$output_dir/: if ($output_dir);
		open( FHTAB, ">$fhtab" ) || die "Can't open $fhtab for writing: $!\n";
		$output = \*FHTAB;
	}
	else {
		@line   = <STDIN>;
		$output = \*STDOUT;
	}

	#parse file content
	my $n = 0;
	while ( $n < @line ) {

		#get program used
		if ( $line[$n] =~ /hmmsearch/ ) {
			$method = 'hmmsearch';
			print "Method: $method\n" if ($debug);
		}
		elsif ( $line[$n] =~ /hmmpfam/ ) {
			$method = 'hmmpfam';
			print "Method: $method\n" if ($debug);
		}
		else {
			if ( $method eq '' ) {
				if ( \*FHTAB ) {
					close FHTAB;
					unlink "$file.htab"
					  if ( !-s "$file.htab" );
				}
				die "***Error: unknown search program used: $line[$n]\n";
			}
		}
		if ( $line[$n] =~ /^HMMER (\d)\.(\S+) \(/ ) {
			my ( $maj_ver, $min_ver ) = ( $1, $2 );
			print "Version: $maj_ver.$min_ver\n"
			  if ($debug);
			if ( $maj_ver == 2 ) {
				if ( $min_ver eq '1.1' ) {
					$version = 1;
				}
				else {
					$version = 2;
				}
			}
			else {
				if ( \*FHTAB ) {
					close FHTAB;
					unlink "$file.htab"
					  if ( !-s "$file.htab" );
				}
				die
				  "***Error: invalid HMMer version '$maj_ver.$min_ver' used.\n";
			}
		}
		elsif ( $line[$n] =~ /^Logical Depth HMMER (\d+)\.(\S+)/ ) {
			my ( $maj_ver, $min_ver ) = ( $1, $2 );
			print "Version: $maj_ver.$min_ver\n"
			  if ($debug);
			$version =
			  2;    # Logical Depth HMMer currently uses 2.2g output format
		}

		#get sequence db name for hmmsearch
		if ( $line[$n] =~ /^Sequence database:\s+([\w\-.]+)/ ) {
			$query_db = $1;
			print "Sequence database: $query_db\n"
			  if ($debug);
		}

		#get HMM db name for hmmpfam
		if ( $line[$n] =~ /^HMM file:\s+/ ) {
			if ( $' ne '' ) {
				$query_db = $';
				chomp $query_db;
				$query_db =~ s/\t//g;
				$query_db =~ s/^\s+//;
				$query_db =~ s/\s+$//;
				print "HMM database: $query_db\n"
				  if ($debug);
			}
		}
		if ( $version == 1 ) {
			if (
				(
					   $line[$n] =~ /^Query HMM: ([\w.\-]+)\|\|/
					or $line[$n] =~ /^Query:\s+(\S+)/
				)
				&& $seq{number} > 0
			  )
			{

				#get hmm length from either DB or HMM file
				&print_parse_hmm_hit(
					$db_proc,      $db,             $output,
					$method,       \%seq,           $query_obj,
					$prot_desc,    $query_db,       $debug,
					$noise_cutoff, $trusted_cutoff, $tb1_cutoff,
					$tb2_cutoff,   $te1_cutoff,     $te2_cutoff,
					$inverse
				  )
				  unless ($quiet);
				$query_obj = $prot_desc = "";
				%seq = ();
			}

			#get query hmm name for hmmsearch
			if ( $line[$n] =~ /^Query HMM: ([\w.\-]+)\|/ ) {
				$query_obj = $1;
				print "query HMM: $query_obj\n"
				  if ($debug);
			}

			#get query sequence name for hmmpfam
			if ( $line[$n] =~ /^Query:\s+(\S+)/ ) {
				$query_obj = $1;
				$prot_desc = '';
				if ( $' ne '' ) {
					$prot_desc = $';
					chomp $prot_desc;
					$prot_desc =~ s/\t/ /g;
					$prot_desc =~ s/^\s+//;
					$prot_desc =~ s/\s+$//;
				}
				print "query seq: $query_obj\n"
				  if ($debug);
			}
		}
		elsif ( $version == 2 ) {

			#get query sequence name for hmmpfam
			if ( $line[$n] =~ /^Query sequence:\s+(\S+)/ ) {
				my $tmp_obj = $1;
				&print_parse_hmm_hit(
					$db_proc,      $db,             $output,
					$method,       \%seq,           $query_obj,
					$prot_desc,    $query_db,       $debug,
					$noise_cutoff, $trusted_cutoff, $tb1_cutoff,
					$tb2_cutoff,   $te1_cutoff,     $te2_cutoff,
					$inverse
				  )
				  unless ($quiet);
				$query_obj = $tmp_obj;
				$prot_desc = "";
				%seq       = ();
				print "query seq: $query_obj\n"
				  if ($debug);
			}

			#get query hmm name for hmmsearch
			if ( $line[$n] =~ /^Query HMM:\s+(\S+)/ ) {
				$query_obj = $1;
				print "query HMM: $query_obj\n"
				  if ($debug);
			}
			if ( $line[$n] =~ /^Description:\s+(.+)/ ) {
				$prot_desc = $1;
				chomp $prot_desc;
				$prot_desc =~ s/\t/ /g;
				$prot_desc =~ s/^\s+//;
				$prot_desc =~ s/\s+$//;
			}
		}

		# get header, total score, e_value, number of domains of sequences for hmmsearch or hmmpfam
		if ($line[$n] =~ /^(Sequence\s+)Description\s+Score\s+E-value\s+(?:N|\#D)/	|| $line[$n] =~	/^(Model\s+)Description\s+Score\s+E-value\s+(?:N|\#D)/) {
			my $m = 0;
			my $seqid_length = length($1);

			# if these are results from searches on a multi-sequence input file
			# this return should not happen
			unless ($multi) {
				# create one line file if there are no hits.
				if ( $line[ $m + $n + 2 ] =~ /\[no hits above thresholds\]/ ) {
					print $output "No hits above thresholds.\n" ;
					###return ();   #### <---- this line was causing the program to exit even if other files followed the one with no hits!!!
					#### Removed by selengut 6/11/07
				}
			}
			while ( $line[ $m + $n + 2 ] =~ /^\S+/ ) {
				my @data = split /\s+/, $line[ $m + $n + 2 ];
				$seq{$m}{header}  = shift @data;
				$seq{$m}{number}  = pop @data;
				$seq{$m}{e_value} = pop @data;
				$seq{$m}{score}   = pop @data;
				$seq{$m}{comment} = join " ", @data;
				print "$m --- $seq{$m}{header}\t$seq{$m}{comment}\t$seq{$m}{score}\t$seq{$m}{e_value}\t$seq{$m}{number}\n" if ($debug);
				++$m;
			}
			$seq{number} = $m;
		}

		# get seq-f, seq-t, hmm-f, hmm-t, score, e_value for each domain for hmmsearch or hmmpfam
		if ( $line[$n] =~ /^Sequence\s+Domain\s+seq-f\s+seq-t\s+hmm-f\s+hmm-t\s+score\s+E-value/i or $line[$n] =~	/^Model\s+Domain\s+seq-f\s+seq-t\s+hmm-f\s+hmm-t\s+score\s+E-value/i  )	{
			my $m = 0;
			while ($line[ $m + $n + 2 ] =~ /^(\S+)\s+(\d+)\/(\d+)\s+(\d+)\s+(\d+).+?(\d+)\s+(\d+).+?(-?\d\S*)\s+(\d\S*)/) {
				for my $k ( 0 .. $seq{number} - 1 ) {
					if ( $seq{$k}{header} eq $1 ) {
						$seq{$k}{$2}{seq_f}   = $4;
						$seq{$k}{$2}{seq_t}   = $5;
						$seq{$k}{$2}{hmm_f}   = $6;
						$seq{$k}{$2}{hmm_t}   = $7;
						$seq{$k}{$2}{score}   = $8;
						$seq{$k}{$2}{e_value} = $9;
						print "***Error: number of domain do not match\n" if ( $3 != $seq{$k}{number} and $debug );
						print "$m --- $1\t$2\t$3\t$4\t$5\t$6\t$7\t$8\t$9\n" if ($debug);
					}
				}
				++$m;
			}
		}

		#######################################################################################
		# get protein and HMM sequences
		#######################################################################################
		if (   $line[$n] =~ /^Alignments of top-scoring domains:/ && $method eq 'hmmsearch' ) {
			my ( %align, %posi,  %align_seq );
			my ( $s_hmm, $e_hmm, $hmm_max_len ) = ( 10000, 0, 0 );

			#get the maximum range of hmm sequnces, required for fragment model
			for my $k1 ( 0 .. $seq{number} - 1 ) {
				for my $k2 ( 1 .. $seq{$k1}{number} ) {
					$s_hmm = $seq{$k1}{$k2}{hmm_f} if ( $seq{$k1}{$k2}{hmm_f} < $s_hmm );
					$e_hmm = $seq{$k1}{$k2}{hmm_t} if ( $seq{$k1}{$k2}{hmm_t} > $e_hmm );
				}
			}

			my $m = 1;
			while ( $line[ $n + $m ] !~ /^Histogram of all scores:/ ) {
				if ( $line[ $n + $m ] =~ /^\S+/ ) {
					for my $k ( 0 .. $seq{number} - 1 ) {# processing each sequence
						next  if ( $b1_cutoff > $seq{$k}{score}	or $e1_cutoff < $seq{$k}{e_value} );
						if ( $line[ $n + $m ] =~ /^\Q$seq{$k}{header}\E:\s+domain\s+(\d+)/ ) {
							my $domain = $1;
							next  if ( $b2_cutoff > $seq{$k}{$domain}{score} or $e2_cutoff < $seq{$k}{$domain}{e_value} );
							## get sequence and store in %align
							while ($line[ $m + $n + 1 ] =~ /^\s+/ && $line[ $m + $n + 3 ] =~ /^\s+([^\|\.\:\/\s]+((\||\.|\:|\/)[^\|\.\:\/\s]+)?)/ && index( $seq{$k}{header}, $1 ) == 0 )	{
								$align{$k}{$domain}{prot} .= $3 if ( $line[ $m + $n + 3 ] =~ /^\s+(\S+)\s+(\d+|-)\s+(\S+)\s+(\d+|-)/ );
								$align{$k}{$domain}{hmm} .= $line[ $m + $n + 1 ];
								$m += 4;
							}
							$align{$k}{$domain}{hmm} =~ s/[\s\n]//g;
							$align{$k}{$domain}{hmm} =~ s/\*->|<-\*//g; # can not merge since <-* might be broken to two sections
							$align{$k}{$domain}{show} = 1; # means this line is above all cutoff and should be printed out later
							die "***Error: wrong character(s) \"$&\" in HMM sequence $align{$k}{$domain}{hmm} for file $file\n" if($align{$k}{$domain}{hmm} =~ /[^a-zA-Z.]/ );
							
							my $prot = $align{$k}{$domain}{prot};
							## check first and last 30 amino acids of the protein sequence
							##   and record the number of gaps in two end regions
							my $fstr = substr($prot, 0, 30);
							my $tstr = substr($prot, length($prot)-30, 30);
							my $fgap = ($fstr =~ tr/-//);
							my $tgap = ($tstr =~ tr/-//);
								
							$seq{$k}{$domain}{gap_f} = $fgap;
							$seq{$k}{$domain}{gap_t} = $tgap;
					
					#		print $seq{$k}{header}, ":\t";
					#		print $align{$k}{$domain}{prot}, "\t", $seq{$k}{$domain}{gap_f}, "\t", $seq{$k}{$domain}{gap_t}, "\n";
											
							last;
						}
					}
				}
				++$m;
			}

			#end of job
			$n += $m;
		}
		++$n;
	}

	&print_parse_hmm_hit(
		$db_proc,    $db,           $output,         $method,
		\%seq,       $query_obj,    $prot_desc,      $query_db,
		$debug,      $noise_cutoff, $trusted_cutoff, $tb1_cutoff,
		$tb2_cutoff, $te1_cutoff,   $te2_cutoff,     $inverse
	  )
	  unless ($quiet);

	close FHTAB;
	unlink "$file.htab" if ( !-s "$file.htab" );
	return "success";
}

#############################################################################################
## Function from hmm_lib.pl
#############################################################################################
sub print_parse_hmm_hit {
	use strict;
	my (
		$db_proc,    $db,           $output,         $method,
		$seq_r,      $query_obj,    $prot_desc,      $query_db,
		$debug,      $noise_cutoff, $trusted_cutoff, $tb1_cutoff,
		$tb2_cutoff, $te1_cutoff,   $te2_cutoff,     $inverse
	  )
	  = @_;

	my ( $hmm_len, $hmm_com_name );
	if ( $db_proc ne '' ) {
		if ( $method eq 'hmmsearch' ) {
			my $ref = &do_query( $db_proc, "select hmm_len, trusted_cutoff, noise_cutoff, hmm_com_name from $db..hmm2 where hmm_acc = \"$query_obj\" and is_current = 1");
			$hmm_len        = $$ref[0]{hmm_len};
			$noise_cutoff   = $$ref[0]{noise_cutoff} if ( $noise_cutoff eq '' );
			$trusted_cutoff = $$ref[0]{trusted_cutoff} if ( $trusted_cutoff eq '' );
			$hmm_com_name = $$ref[0]{hmm_com_name};
			$hmm_com_name =~ s/\t/ /g;
			print "test hmm_len, trusted, noise, hmm_com_name: $hmm_len, $trusted_cutoff, $noise_cutoff, $hmm_com_name\n" if ($debug);
		}
		elsif ( $method eq 'hmmpfam' ) {
			for my $n ( 0 .. $$seq_r{number} - 1 ) {
				my $query = "select hmm_len, trusted_cutoff, noise_cutoff, hmm_com_name from $db..hmm2 where hmm_acc = \"$$seq_r{$n}{header}\" and is_current = 1";
				my $ref = &do_query( $db_proc, $query );
				$$seq_r{$n}{hmm_len}        = $$ref[0]{hmm_len};
				$$seq_r{$n}{noise_cutoff}   = $$ref[0]{noise_cutoff};
				$$seq_r{$n}{trusted_cutoff} = $$ref[0]{trusted_cutoff};
				$$seq_r{$n}{comment}        = $$ref[0]{hmm_com_name};
				$$seq_r{$n}{comment} =~ s/\t/ /g;
				print "seq \#, hmm_len, trusted, noise, hmm_com_name: $n, $$seq_r{$n}{trusted_cutoff}, $$seq_r{$n}{noise_cutoff}, $$seq_r{$n}{comment}\n" if ($debug);
			}
		}
	}

	if ( $$seq_r{number} > 0 ) {
		my ( $day, $month, $year ) =
		  ( (localtime)[3], (localtime)[4] + 1, (localtime)[5] + 1900 );
		print $output "1 HMM\t2 htab_date\t3 hmm_length\t4 method\t5 query_DB\t6 protein\t7 hmm_f\t8 hmm_t\t9 protein_f\t10 protein_t\t11 NULL\t12 domain_score\t13 total_score\t14 domain \#\t15 \# of domains\t16 HMM description\t17 protein description\t18 trusted_cutoff\t19 noise_cutoff\t20 total_E_value\t21 domain_E_value\n" if ($debug);
		for my $m ( 0 .. $$seq_r{number} - 1 ) {
			if ($inverse) {
				next if ( $tb1_cutoff < $$seq_r{$m}{score} or $te1_cutoff > $$seq_r{$m}{e_value} );
			}
			else {
				next if ( $tb1_cutoff > $$seq_r{$m}{score} or $te1_cutoff < $$seq_r{$m}{e_value} );
			}
			for my $n ( 1 .. $$seq_r{$m}{number} ) {
				if ( !$$seq_r{$m}{$n}{seq_f} ) {
					next;
				}
				if ($inverse) {
					next if ( $tb2_cutoff < $$seq_r{$m}{$n}{score} or $te2_cutoff > $$seq_r{$m}{$n}{e_value} );
				}
				else {
					next if ( $tb2_cutoff > $$seq_r{$m}{$n}{score} or $te2_cutoff < $$seq_r{$m}{$n}{e_value} );
				}
				if ( $method eq 'hmmsearch' ) {
					print $output "$query_obj\t$month-$day-$year\t$hmm_len\t$method\t$query_db\t";
					print $output "$$seq_r{$m}{header}\t$$seq_r{$m}{$n}{hmm_f}\t$$seq_r{$m}{$n}{hmm_t}\t$$seq_r{$m}{$n}{seq_f}\t$$seq_r{$m}{$n}{seq_t}\t";
					print $output "$$seq_r{$m}{$n}{gap_f}\t$$seq_r{$m}{$n}{gap_t}\t\t$$seq_r{$m}{$n}{score}\t$$seq_r{$m}{score}\t$n\t$$seq_r{$m}{number}\t";
					print $output "$hmm_com_name\t$$seq_r{$m}{comment}\t$trusted_cutoff\t$noise_cutoff\t$$seq_r{$m}{e_value}\t$$seq_r{$m}{$n}{e_value}\n";
				}
				elsif ( $method eq 'hmmpfam' ) {
					print $output
"$$seq_r{$m}{header}\t$month-$day-$year\t$$seq_r{$m}{hmm_len}\t$method\t$query_db\t$query_obj\t$$seq_r{$m}{$n}{hmm_f}\t$$seq_r{$m}{$n}{hmm_t}\t$$seq_r{$m}{$n}{seq_f}\t$$seq_r{$m}{$n}{seq_t}\t\t$$seq_r{$m}{$n}{score}\t$$seq_r{$m}{score}\t$n\t$$seq_r{$m}{number}\t$$seq_r{$m}{comment}\t$prot_desc\t$$seq_r{$m}{trusted_cutoff}\t$$seq_r{$m}{noise_cutoff}\t$$seq_r{$m}{e_value}\t$$seq_r{$m}{$n}{e_value}\n"
					  ;
				}
			}
		}
	}
}

###############################################################################
## function from hmm_lib.pl
###############################################################################
sub connect_db {
	use strict;
	use Carp;
	my ( $db, $db_type, $server, $user, $password ) = @_;
	die("no user name provided ")
	  if ( $user eq '' );
	die("no password provided ")
	  if ( $password eq '' );
	my $db_proc =
	  ( DBI->connect( "dbi:$db_type:server=$server", $user, $password ) );
	carp "$DBI::errstr\n"
	  if ( $DBI::errstr ne '' );
	return
	  unless ( defined $db_proc );
	$db_proc->{RaiseError} = 1;    # program dies if there is an error
	$db_proc->{PrintError} = 1;
	carp "$DBI::errstr\n"
	  if ( $DBI::errstr ne '' );
	$db_proc->do("use $db");
	carp "$DBI::errstr\n"
	  if ( $DBI::errstr ne '' );
	$db_proc->do("set textsize 200000000");
	carp "$DBI::errstr\n"
	  if ( $DBI::errstr ne '' );
	return $db_proc;
}

sub do_query {
	use strict;
	use Carp;
	my ( $db_proc, $query, $noFetch, $log_header, $log_r ) = @_;
	return unless ( defined $db_proc );
	$log_header .= "--sub do_query";
	my $statementHandle = $db_proc->prepare($query);
	if ( $DBI::errstr ne '' ) {
		carp "$DBI::errstr\n$query\n";
		$$log_r .= "***Error: $log_header--$DBI::errstr\n"
		  if ($log_r);

		#	print "Trouble preparing this do_query:\n$query\n";
	}
	$statementHandle->execute();
	if ( $DBI::errstr ne '' ) {
		carp "$DBI::errstr\n$query\n";
		$$log_r .= "***Error: $log_header--$DBI::errstr\n"
		  if ($log_r);

		#	print "Trouble executing this do_query:\n$query\n";
	}

	#
	my $array_r = $statementHandle->fetchall_arrayref( {} )
	  unless ($noFetch);
	if ( $DBI::errstr ne '' ) {
		carp "$DBI::errstr\n$query\n";
		$$log_r .= "***Error: $log_header--$DBI::errstr\n"
		  if ($log_r);
	}

	#
	$statementHandle->finish;
	if ( $DBI::errstr ne '' ) {
		carp "$DBI::errstr\n$query\n";
		$$log_r .= "***Error: $log_header--$DBI::errstr\n"
		  if ($log_r);
	}
	return $array_r;
}
